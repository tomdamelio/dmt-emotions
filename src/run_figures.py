# -*- coding: utf-8 -*-
"""
Generate publication-ready composite panels for physiological figures (Nature Human Behaviour).

This script generates figures by running the individual analysis scripts as subprocesses
to create fresh plots, then assembles them into final composite figures.

NOTE: Figure 1 is a methods figure created separately. This script generates Figures 2-5.

Figure 2 (3x2 grid - Combined HR, SMNA, RVT):
  A-F: Generated by running run_ecg_hr_analysis.py, run_eda_smna_analysis.py, run_resp_rvt_analysis.py

Figure 3 (Composite Autonomic Arousal Index - 4 panels):
  A-D: Generated by running run_composite_arousal_index.py

Figure 4 (TET Analysis - 5 panels):
  A-E: Generated by running run_tet_analysis.py

Figure 5 (CCA Analysis - 4 panels):
  A-D: Generated from results/coupling/ data

Supplementary Figures:
  S1-S5: Various supplementary visualizations

Usage:
  python src/run_figures.py                    # Generate all figures
  python src/run_figures.py --figures 2 3      # Generate only figures 2 and 3
  python src/run_figures.py --figures 4        # Generate only figure 4
  python src/run_figures.py --figures S1 S2    # Generate only supplementary figures
  python src/run_figures.py --figures 2 S5     # Mix of main and supplementary
"""

import argparse
import os
import sys
from pathlib import Path
from typing import List, Tuple, Optional, Dict

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import pandas as pd

# Import centralized figure configuration
sys.path.insert(0, str(Path(__file__).parent))
try:
    from figure_config import (
        FONT_SIZE_PANEL_LABEL, FONT_SIZE_TITLE, FONT_SIZE_AXIS_LABEL,
        FONT_SIZE_TICK_LABEL, FONT_SIZE_LEGEND, FONT_SIZE_LEGEND_SMALL,
        DOUBLE_COL_WIDTH, FIG_SIZE_DOUBLE, FIG_SIZE_DOUBLE_TALL, apply_rcparams
    )
    apply_rcparams()
    PANEL_LABEL_SIZE = FONT_SIZE_PANEL_LABEL
except ImportError:
    # Fallback to Nature-compliant defaults
    PANEL_LABEL_SIZE = 12
    FONT_SIZE_TITLE = 10
    FONT_SIZE_AXIS_LABEL = 9
    FONT_SIZE_TICK_LABEL = 8
    FONT_SIZE_LEGEND = 8
    FONT_SIZE_LEGEND_SMALL = 7
    DOUBLE_COL_WIDTH = 7.2


# Project paths
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent
EDA_ROOT = PROJECT_ROOT / 'results' / 'eda'
ECG_ROOT = PROJECT_ROOT / 'results' / 'ecg'
RESP_ROOT = PROJECT_ROOT / 'results' / 'resp'
TET_ROOT = PROJECT_ROOT / 'results' / 'tet'
OUT_DIR = PROJECT_ROOT / 'results' / 'figures'


def _load_image(path: str):
    """Load image from path, return None if not found."""
    if not os.path.exists(path):
        print(f"[WARN] Missing image: {path}")
        return None
    try:
        return mpimg.imread(path)
    except Exception as e:
        print(f"[WARN] Failed to load {path}: {e}")
        return None


def _place(ax, img, label: str, label_xy: Tuple[float, float] = (-0.03, 1.08)):
    """Place image and label in subplot."""
    ax.axis('off')
    if img is not None:
        ax.imshow(img)
    ax.text(label_xy[0], label_xy[1], label, transform=ax.transAxes,
            ha='left', va='top', fontsize=PANEL_LABEL_SIZE, fontweight='bold', color='black')


def create_figure_2() -> str:
    """Create Figure 2: Combined HR, SMNA, and RVT analysis (3x2 grid).
    
    Generates the figure by running the analysis scripts as subprocesses to
    generate fresh plots, then assembling them into the final figure.
    
    Note: This requires that the raw data files exist for each modality.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    import subprocess
    
    # Run each analysis script to generate fresh plots
    print("  Generating ECG/HR plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_ecg_hr_analysis.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ ECG analysis completed")
        else:
            print(f"    [WARN] ECG analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] ECG analysis timed out")
    except Exception as e:
        print(f"    [WARN] ECG analysis failed: {e}")
    
    print("  Generating EDA/SMNA plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_eda_smna_analysis.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ EDA analysis completed")
        else:
            print(f"    [WARN] EDA analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] EDA analysis timed out")
    except Exception as e:
        print(f"    [WARN] EDA analysis failed: {e}")
    
    print("  Generating Resp/RVT plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_resp_rvt_analysis.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ Resp analysis completed")
        else:
            print(f"    [WARN] Resp analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] Resp analysis timed out")
    except Exception as e:
        print(f"    [WARN] Resp analysis failed: {e}")
    
    # Now load the generated images and assemble the figure
    print("  Assembling Figure 2...")
    imgs = [
        _load_image(str(ECG_ROOT / 'hr' / 'plots' / 'all_subs_ecg_hr.png')),
        _load_image(str(ECG_ROOT / 'hr' / 'plots' / 'lme_coefficient_plot.png')),
        _load_image(str(EDA_ROOT / 'smna' / 'plots' / 'all_subs_smna.png')),
        _load_image(str(EDA_ROOT / 'smna' / 'plots' / 'lme_coefficient_plot.png')),
        _load_image(str(RESP_ROOT / 'rvt' / 'plots' / 'all_subs_resp_rvt.png')),
        _load_image(str(RESP_ROOT / 'rvt' / 'plots' / 'lme_coefficient_plot.png')),
    ]

    # Use Nature Human Behaviour double column width (183mm = 7.2 inches)
    # Create figure with 3 rows x 2 columns
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 1.0))
    
    # Calculate aspect ratios from actual images to maintain proportions
    # Left images (timeseries) are wider, right images (coefficient) are narrower
    # Use width_ratios based on actual image dimensions
    if imgs[0] is not None and imgs[1] is not None:
        left_aspect = imgs[0].shape[1] / imgs[0].shape[0]  # width/height
        right_aspect = imgs[1].shape[1] / imgs[1].shape[0]
        width_ratio = left_aspect / right_aspect
    else:
        width_ratio = 2.0
    
    gs = fig.add_gridspec(3, 2, width_ratios=[width_ratio, 1.0], 
                          wspace=0.05, hspace=0.08,
                          left=0.01, right=0.99, top=0.97, bottom=0.03)
    
    axes = [fig.add_subplot(gs[i, j]) for i in range(3) for j in range(2)]
    
    # Place images maintaining their aspect ratio
    for idx, (ax, img) in enumerate(zip(axes, imgs)):
        ax.axis('off')
        if img is not None:
            # Use aspect='equal' to maintain image proportions
            ax.imshow(img, aspect='equal')
            # Adjust axis limits to remove whitespace
            ax.set_xlim(0, img.shape[1])
            ax.set_ylim(img.shape[0], 0)
    
    # Add panel labels - calculate positions based on gridspec
    labels = ['A', 'B', 'C', 'D', 'E', 'F']
    row_tops = [0.97, 0.66, 0.35]  # Approximate top positions for each row
    
    for i, label in enumerate(labels):
        row = i // 2
        col = i % 2
        # Position labels at consistent heights per row
        if col == 0:
            x_pos = 0.01
        else:
            x_pos = width_ratio / (width_ratio + 1.0) + 0.01
        y_pos = row_tops[row]
        fig.text(x_pos, y_pos, label, 
                fontsize=PANEL_LABEL_SIZE, fontweight='bold', ha='left', va='top')
    
    out_path = str(OUT_DIR / 'figure_2.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_3() -> str:
    """Create Figure 3: Composite Autonomic Arousal Index (4 panels).
    
    Generates the figure by running the composite arousal index analysis script
    as a subprocess to generate fresh plots, then assembling them into the final figure.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    COMPOSITE_ROOT = PROJECT_ROOT / 'results' / 'composite' / 'plots'
    
    import subprocess
    
    print("  Generating Composite Arousal Index plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_composite_arousal_index.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ Composite analysis completed")
        else:
            print(f"    [WARN] Composite analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] Composite analysis timed out")
    except Exception as e:
        print(f"    [WARN] Composite analysis failed: {e}")

    # Now load the generated images and assemble the figure
    print("  Assembling Figure 3...")
    imgs = [
        _load_image(str(COMPOSITE_ROOT / 'pca_scree.png')),
        _load_image(str(COMPOSITE_ROOT / 'pca_pc1_loadings.png')),
        _load_image(str(COMPOSITE_ROOT / 'lme_coefficient_plot.png')),
        _load_image(str(COMPOSITE_ROOT / 'all_subs_composite.png')),
    ]

    # Use Nature Human Behaviour double column width
    # 4 panels: A (scree), C (loadings) in left column, B (coefficients) right top, D (timeseries) bottom
    # Reduced height and tighter spacing to match Figure 2 style
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.85))
    gs = fig.add_gridspec(3, 2, width_ratios=[0.45, 1.0], wspace=0.08, hspace=0.08,
                          left=0.02, right=0.99, top=0.98, bottom=0.02,
                          height_ratios=[1, 1, 1.8])
    
    ax_A = fig.add_subplot(gs[0, 0])  # Scree plot (top-left)
    ax_C = fig.add_subplot(gs[1, 0])  # Loadings bar (middle-left)
    ax_B = fig.add_subplot(gs[0:2, 1])  # Coefficient plot (right, spans 2 rows)
    ax_D = fig.add_subplot(gs[2, :])  # Timeseries (bottom, full width)
    
    for ax, img in zip([ax_A, ax_C, ax_B, ax_D], imgs):
        ax.axis('off')
        if img is not None:
            ax.imshow(img, aspect='auto')
    
    # Panel labels positioned consistently
    for ax, label in zip([ax_A, ax_B, ax_C, ax_D], ['A', 'B', 'C', 'D']):
        pos = ax.get_position()
        fig.text(pos.x0 - 0.01, pos.y1 + 0.01, label,
                fontsize=PANEL_LABEL_SIZE, fontweight='bold', ha='left', va='top')

    out_path = str(OUT_DIR / 'figure_3.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_4() -> str:
    """Create Figure 4: TET Analysis (5 panels).
    
    Generates the figure by calling the plotting functions from run_tet_analysis.py
    directly, ensuring identical layout to the original composite figure.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    # Import the TET analysis module and use its functions directly
    import sys
    sys.path.insert(0, str(SCRIPT_DIR))
    
    try:
        from run_tet_analysis import (
            load_data, compute_pca, fit_lme_models, compute_time_courses,
            compute_significance_masks, plot_figure3, DATA_PATH
        )
    except ImportError as e:
        print(f"[ERROR] Could not import run_tet_analysis: {e}")
        return ""
    
    # Check if data exists
    if not DATA_PATH.exists():
        print(f"[ERROR] TET data not found: {DATA_PATH}")
        print("  Run preprocessing first.")
        return ""
    
    print("  Loading TET data and computing analysis...")
    
    # Run the analysis pipeline
    df = load_data()
    df, loadings, variance_explained = compute_pca(df)
    lme_results, df_all = fit_lme_models(df)
    time_courses = compute_time_courses(df)
    significance = compute_significance_masks(df)
    
    # Generate the figure using the original function
    # This ensures identical layout
    fig_path = plot_figure3(df, time_courses, loadings, variance_explained, 
                            lme_results, significance)
    
    # Copy to the figures output directory
    import shutil
    out_path = str(OUT_DIR / 'figure_4.png')
    shutil.copy2(fig_path, out_path)
    
    return out_path


def create_figure_5() -> str:
    """Create Figure 5: Combined CCA Analysis (4 panels)."""
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    CCA_ROOT = PROJECT_ROOT / 'results' / 'coupling'
    
    try:
        loadings_df = pd.read_csv(CCA_ROOT / 'cca_loadings.csv')
        cv_folds_df = pd.read_csv(CCA_ROOT / 'cca_cross_validation_folds.csv')
        cv_summary_df = pd.read_csv(CCA_ROOT / 'cca_cross_validation_summary.csv')
        merged_data_df = pd.read_csv(CCA_ROOT / 'merged_physio_tet_data.csv')
    except FileNotFoundError as e:
        print(f"[ERROR] Missing CCA data file: {e}")
        return ""
    
    plt.rcParams.update({
        'font.family': 'sans-serif', 'font.size': 7, 'axes.labelsize': 7,
        'axes.titlesize': 8, 'xtick.labelsize': 6, 'ytick.labelsize': 7,
        'legend.fontsize': 6, 'axes.linewidth': 0.5,
    })
    
    tab20c = plt.cm.tab20c.colors
    physio_colors = {'HR': tab20c[0], 'SMNA_AUC': tab20c[4], 'RVT': tab20c[8]}
    gray_colors = [tab20c[12], tab20c[13], tab20c[14], tab20c[15]]
    color_rs, color_rs_edge = tab20c[17], tab20c[16]
    color_dmt, color_dmt_edge = tab20c[13], tab20c[12]
    
    # Updated figure size from pylustrator
    fig = plt.figure(figsize=(17.370000/2.54, 14.240000/2.54))
    gs = fig.add_gridspec(2, 2, width_ratios=[1, 1.5], wspace=0.35, hspace=0.4)
    
    ax_A, ax_B = fig.add_subplot(gs[0, 0]), fig.add_subplot(gs[0, 1])
    ax_C, ax_D = fig.add_subplot(gs[1, 0]), fig.add_subplot(gs[1, 1])
    
    state, cv = 'DMT', 1
    data = loadings_df[(loadings_df['state'] == state) & (loadings_df['canonical_variate'] == cv)]
    physio_data = data[data['variable_set'] == 'physio'].sort_values('loading', ascending=True)
    tet_data = data[data['variable_set'] == 'tet'].sort_values('loading', ascending=True)
    
    physio_labels = {'HR': ('ECG', 'HR'), 'SMNA_AUC': ('EDA', 'SMNA'), 'RVT': ('Resp', 'RVT')}
    tet_labels = {'emotional_intensity': 'Emotional Intensity', 'interoception': 'Interoception',
                  'unpleasantness': 'Unpleasantness', 'pleasantness': 'Pleasantness',
                  'bliss': 'Bliss', 'anxiety': 'Anxiety'}
    
    # Panel A: Physio loadings
    for i, (_, row) in enumerate(physio_data.iterrows()):
        ax_A.barh(i, row['loading'], height=0.6, 
                 color=physio_colors.get(row['variable_name'], '#666'), alpha=0.85)
    ax_A.set_yticks(range(len(physio_data)))
    ax_A.set_yticklabels([physio_labels.get(v, (v, v))[0] for v in physio_data['variable_name']])
    ax_A.set_xlabel('Canonical Loading')
    ax_A.set_title('Physiological Variables', fontweight='bold')
    ax_A.axvline(0, color='black', linewidth=0.5, alpha=0.3)
    ax_A.spines['top'].set_visible(False)
    ax_A.spines['right'].set_visible(False)
    
    # Panel B: TET loadings
    for i, (_, row) in enumerate(tet_data.iterrows()):
        ax_B.barh(i, row['loading'], height=0.6, color=gray_colors[i % 4], alpha=0.85)
    ax_B.set_yticks(range(len(tet_data)))
    ax_B.set_yticklabels([tet_labels.get(v, v) for v in tet_data['variable_name']])
    ax_B.set_xlabel('Canonical Loading')
    ax_B.set_title('Affective Dimensions', fontweight='bold')
    ax_B.axvline(0, color='black', linewidth=0.5, alpha=0.3)
    ax_B.spines['top'].set_visible(False)
    ax_B.spines['right'].set_visible(False)
    
    # Panel C: CV boxplots
    cv_cv1 = cv_folds_df[cv_folds_df['canonical_variate'] == 1]
    rs_cv = cv_cv1[cv_cv1['state'] == 'RS']['r_oos'].values
    dmt_cv = cv_cv1[cv_cv1['state'] == 'DMT']['r_oos'].values
    
    bp = ax_C.boxplot([rs_cv, dmt_cv], positions=[0.8, 1.6], widths=0.3, patch_artist=True)
    bp['boxes'][0].set_facecolor(color_rs)
    bp['boxes'][1].set_facecolor(color_dmt)
    ax_C.set_xticks([0.8, 1.6])
    ax_C.set_xticklabels(['RS', 'DMT'])
    ax_C.set_ylabel('Out-of-sample r')
    ax_C.set_title('Cross-validation (CV1)', fontweight='bold')
    ax_C.axhline(0, color='black', linestyle='--', linewidth=0.5, alpha=0.5)
    ax_C.spines['top'].set_visible(False)
    ax_C.spines['right'].set_visible(False)
    
    # Panel D: Scatterplot
    from sklearn.cross_decomposition import CCA
    dmt_merged = merged_data_df[merged_data_df['state'] == 'DMT'].copy()
    X = dmt_merged[['HR', 'SMNA_AUC', 'RVT']].values
    Y = dmt_merged[['pleasantness_z', 'unpleasantness_z', 'emotional_intensity_z',
                    'interoception_z', 'bliss_z', 'anxiety_z']].values
    subjects = dmt_merged['subject'].values
    
    valid = ~(np.isnan(X).any(axis=1) | np.isnan(Y).any(axis=1))
    X, Y, subjects = X[valid], Y[valid], subjects[valid]
    X = (X - X.mean(0)) / X.std(0)
    Y = (Y - Y.mean(0)) / Y.std(0)
    
    cca = CCA(n_components=2)
    cca.fit(X, Y)
    U, V = cca.transform(X, Y)
    
    tab20 = plt.cm.tab20.colors
    for i, subj in enumerate(np.unique(subjects)):
        mask = subjects == subj
        ax_D.scatter(U[mask, 0], V[mask, 0], s=30, color=tab20[(i % 10) * 2 + 1],
                    alpha=0.7, edgecolors=tab20[(i % 10) * 2], linewidths=0.5, label=subj)
    
    z = np.polyfit(U[:, 0], V[:, 0], 1)
    x_line = np.linspace(U[:, 0].min(), U[:, 0].max(), 100)
    ax_D.plot(x_line, np.poly1d(z)(x_line), 'r--', linewidth=1.5, alpha=0.8)
    
    in_r = cv_summary_df[(cv_summary_df['state'] == 'DMT') & 
                         (cv_summary_df['canonical_variate'] == 1)]['in_sample_r'].values[0]
    ax_D.set_xlabel('Physiological Score (U1)')
    ax_D.set_ylabel('TET Score (V1)')
    ax_D.set_title('In-sample coupling (DMT)', fontweight='bold')
    ax_D.spines['top'].set_visible(False)
    ax_D.spines['right'].set_visible(False)
    
    # Apply pylustrator layout adjustments
    ax_A.set_position([0.125, 0.5926, 0.2284, 0.2874])
    ax_B.set_position([0.5443, 0.5831, 0.3557, 0.2969])
    ax_C.set_position([0.125, 0.11, 0.2284, 0.3172])  # Panel C position (not in pylustrator output, keeping original)
    ax_D.set_position([0.5136, 0.11, 0.3864, 0.3172])
    
    # Add panel labels with pylustrator positions
    ax_A.text(-0.3429, 1.098, 'A', transform=ax_A.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    ax_B.text(-0.257, 1.095, 'B', transform=ax_B.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    ax_C.text(-0.35, 1.15, 'C', transform=ax_C.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    ax_D.text(-0.1571, 1.15, 'D', transform=ax_D.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    
    # Add r value text with pylustrator position
    ax_D.text(1.004, 1.025, f'r = {in_r:.2f}', transform=ax_D.transAxes,
             ha='right', va='top', fontsize=8, style='italic', fontweight='bold')
    
    # Add legend with pylustrator settings
    ax_D.legend(loc=(0.7973, 0.06528), borderpad=0.2, markerscale=0.9, 
                handlelength=0., ncols=2, fontsize=8)
    
    out_path = str(OUT_DIR / 'figure_5.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
    plt.close()
    return out_path


def create_figure_S1() -> str:
    """Create Figure S1: Stacked subjects for all modalities (1x3 horizontal).
    
    Uses the stacked subject plots generated by the individual analysis scripts.
    Runs the scripts as subprocesses if plots don't exist.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    import subprocess
    
    # Check if plots exist, if not run the analysis scripts
    ecg_stacked = ECG_ROOT / 'hr' / 'plots' / 'stacked_subs_ecg_hr.png'
    eda_stacked = EDA_ROOT / 'smna' / 'plots' / 'stacked_subs_smna.png'
    resp_stacked = RESP_ROOT / 'rvt' / 'plots' / 'stacked_subs_resp_rvt.png'
    
    if not ecg_stacked.exists():
        print("  Generating ECG stacked plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_ecg_hr_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] ECG analysis failed: {e}")
    
    if not eda_stacked.exists():
        print("  Generating EDA stacked plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_eda_smna_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] EDA analysis failed: {e}")
    
    if not resp_stacked.exists():
        print("  Generating Resp stacked plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_resp_rvt_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] Resp analysis failed: {e}")

    # Load generated images
    print("  Assembling Figure S1...")
    imgs = [
        _load_image(str(ecg_stacked)),
        _load_image(str(eda_stacked)),
        _load_image(str(resp_stacked)),
    ]

    # Wider figure with more height to avoid "squashing" panels
    fig_width = DOUBLE_COL_WIDTH * 0.85
    fig_height = DOUBLE_COL_WIDTH * 0.45  # Increased height to stretch panels
    fig = plt.figure(figsize=(fig_width, fig_height))
    
    # Significant spacing between panels, narrower panel C to match height
    gs = fig.add_gridspec(1, 3, wspace=0.15, width_ratios=[1, 1, 0.85],
                          left=0.02, right=0.98, top=0.92, bottom=0.02)
    
    labels = ['A', 'B', 'C']
    
    for i, (img, label) in enumerate(zip(imgs, labels)):
        ax = fig.add_subplot(gs[0, i])
        ax.axis('off')
        if img is not None:
            ax.imshow(img, aspect='auto')
        # Slightly larger labels
        pos = ax.get_position()
        fig.text(pos.x0, pos.y1 + 0.02, label, 
                fontsize=5, fontweight='bold', ha='left', va='bottom')

    out_path = str(OUT_DIR / 'figure_S1.png')
    plt.savefig(out_path, dpi=1800, bbox_inches='tight', facecolor='white')
    plt.close()
    return out_path


def create_figure_S2() -> str:
    """Create Figure S2: DMT ECG HR extended timecourse.
    
    Generates the plot directly using matplotlib, allowing for interactive editing.
    This figure should match the aesthetic of panel A from figure_2.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    print("  Generating Figure S2 (DMT ECG HR extended)...")
    
    # Import ECG analysis functions and data loading utilities
    sys.path.insert(0, str(SCRIPT_DIR))
    try:
        from run_ecg_hr_analysis import (
            SUJETOS_VALIDADOS_ECG, determine_sessions, build_ecg_paths, load_ecg_csv,
            build_rs_ecg_path, USE_SESSION_ZSCORE, ZSCORE_BY_SUBJECT, WINDOW_SIZE_SEC,
            zscore_with_subject_baseline, zscore_with_session_baseline,
            compute_hr_mean_per_window, _compute_fdr_significant_segments,
            COLOR_DMT_HIGH, COLOR_DMT_LOW, tab20c_colors,
            LEGEND_FONTSIZE, LEGEND_MARKERSCALE, LEGEND_BORDERPAD, 
            LEGEND_LABELSPACING, LEGEND_BORDERAXESPAD,
            FONT_SIZE_TITLE, FONT_SIZE_AXIS_LABEL, FONT_SIZE_TICK_LABEL
        )
    except ImportError as e:
        print(f"    [ERROR] Could not import ECG functions: {e}")
        return ""
    
    # Generate the plot directly
    try:
        limit_sec = 1150.0
        total_windows = int(np.floor(limit_sec / WINDOW_SIZE_SEC))
        H_list, L_list = [], []
        
        for subject in SUJETOS_VALIDADOS_ECG:
            try:
                high_session, low_session = determine_sessions(subject)
                p_high, p_low = build_ecg_paths(subject, high_session, low_session)
                d_high = load_ecg_csv(p_high)
                d_low = load_ecg_csv(p_low)
                if d_high is None or d_low is None:
                    continue
                th_abs = d_high['time'].to_numpy()
                yh_abs = pd.to_numeric(d_high['ECG_Rate'], errors='coerce').to_numpy()
                tl_abs = d_low['time'].to_numpy()
                yl_abs = pd.to_numeric(d_low['ECG_Rate'], errors='coerce').to_numpy()
                
                if USE_SESSION_ZSCORE:
                    p_rsh = build_rs_ecg_path(subject, high_session)
                    p_rsl = build_rs_ecg_path(subject, low_session)
                    r_high = load_ecg_csv(p_rsh)
                    r_low = load_ecg_csv(p_rsl)
                    if r_high is None or r_low is None:
                        continue
                    trh_abs = r_high['time'].to_numpy()
                    yrh_abs = pd.to_numeric(r_high['ECG_Rate'], errors='coerce').to_numpy()
                    trl_abs = r_low['time'].to_numpy()
                    yrl_abs = pd.to_numeric(r_low['ECG_Rate'], errors='coerce').to_numpy()
                    
                    if ZSCORE_BY_SUBJECT:
                        _, yh_z, _, yl_z, diag = zscore_with_subject_baseline(
                            trh_abs, yrh_abs, th_abs, yh_abs,
                            trl_abs, yrl_abs, tl_abs, yl_abs
                        )
                        if not diag['scalable']:
                            continue
                        yh, yl = yh_z, yl_z
                    else:
                        _, yh_z, diag_h = zscore_with_session_baseline(trh_abs, yrh_abs, th_abs, yh_abs)
                        _, yl_z, diag_l = zscore_with_session_baseline(trl_abs, yrl_abs, tl_abs, yl_abs)
                        if not (diag_h['scalable'] and diag_l['scalable']):
                            continue
                        yh, yl = yh_z, yl_z
                else:
                    yh, yl = yh_abs, yl_abs
                
                hr_h = [compute_hr_mean_per_window(th_abs, yh, m) for m in range(total_windows)]
                hr_l = [compute_hr_mean_per_window(tl_abs, yl, m) for m in range(total_windows)]
                if None in hr_h or None in hr_l:
                    continue
                H_list.append(np.array(hr_h, dtype=float))
                L_list.append(np.array(hr_l, dtype=float))
            except Exception:
                continue
        
        if not (H_list and L_list):
            print("    [ERROR] No valid ECG data found")
            return ""
        
        H = np.vstack(H_list)
        L = np.vstack(L_list)
        mean_h = np.nanmean(H, axis=0)
        mean_l = np.nanmean(L, axis=0)
        sem_h = np.nanstd(H, axis=0, ddof=1) / np.sqrt(H.shape[0])
        sem_l = np.nanstd(L, axis=0, ddof=1) / np.sqrt(L.shape[0])
        
        x = np.arange(1, total_windows + 1)
        time_minutes = (x - 0.5) * WINDOW_SIZE_SEC / 60.0
        
        # Create figure with Nature-compliant dimensions
        fig, ax = plt.subplots(1, 1, figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.4))
        
        # Compute FDR significant segments
        segs = _compute_fdr_significant_segments(H, L, x, alternative='greater')
        for w0, w1 in segs:
            t0 = (w0 - 1) * WINDOW_SIZE_SEC / 60.0
            t1 = w1 * WINDOW_SIZE_SEC / 60.0
            ax.axvspan(t0, t1, color='0.85', alpha=0.35, zorder=0)
        
        # Plot lines
        l1 = ax.plot(time_minutes, mean_h, color=COLOR_DMT_HIGH, lw=1.5, label='High dose (40mg)')[0]
        ax.fill_between(time_minutes, mean_h - sem_h, mean_h + sem_h, color=COLOR_DMT_HIGH, alpha=0.25)
        l2 = ax.plot(time_minutes, mean_l, color=COLOR_DMT_LOW, lw=1.5, label='Low dose (20mg)')[0]
        ax.fill_between(time_minutes, mean_l - sem_l, mean_l + sem_l, color=COLOR_DMT_LOW, alpha=0.25)
        
        # Legend
        leg = ax.legend([l1, l2], ['High dose (40mg)', 'Low dose (20mg)'], 
                       loc=(0.7116, 0.6871), frameon=True, fancybox=False, 
                       fontsize=FONT_SIZE_LEGEND, borderpad=0.4)
        leg.get_frame().set_facecolor('white')
        leg.get_frame().set_alpha(0.9)
        
        # Labels
        ax.set_xlabel('Time (minutes)', fontsize=FONT_SIZE_AXIS_LABEL)
        ylabel_text = 'HR (Z-scored)' if USE_SESSION_ZSCORE else 'HR (bpm)'
        ax.text(-0.0986, 0.5, 'Electrocardiography', transform=ax.transAxes, 
                fontsize=FONT_SIZE_AXIS_LABEL, fontweight='bold', color=tab20c_colors[0],
                rotation=90, va='center', ha='center')
        ax.text(-0.06, 0.5, ylabel_text, transform=ax.transAxes, 
                fontsize=FONT_SIZE_AXIS_LABEL, fontweight='normal', color='black', 
                rotation=90, va='center', ha='center')
        ax.set_title('DMT', fontweight='bold', fontsize=FONT_SIZE_TITLE)
        ax.tick_params(axis='both', labelsize=FONT_SIZE_TICK_LABEL)
        ax.grid(True, which='major', axis='y', alpha=0.25)
        ax.grid(False, which='major', axis='x')
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        
        # X-axis
        ticks = list(range(0, 20))
        ax.set_xticks(ticks)
        ax.set_xlim(-0.2, 19.2)
        
        plt.tight_layout()
        out_path = str(OUT_DIR / 'figure_S2.png')
        plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()
        
        print(f"    ✓ Figure S2 saved to: {out_path}")
        return out_path
        
    except Exception as e:
        print(f"    [ERROR] Failed to generate Figure S2: {e}")
        import traceback
        traceback.print_exc()
        return ""


def create_figure_S3() -> str:
    """Create Figure S3: Stacked subjects composite arousal index.
    
    Uses the stacked subjects plot generated by the composite analysis script.
    Runs the script as subprocess if plot doesn't exist.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    import subprocess
    
    composite_stacked = PROJECT_ROOT / 'results' / 'composite' / 'plots' / 'stacked_subs_composite.png'
    
    if not composite_stacked.exists():
        print("  Generating stacked subjects composite plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_composite_arousal_index.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] Composite analysis failed: {e}")
    
    print("  Assembling Figure S3...")
    img = _load_image(str(composite_stacked))
    if img is None:
        return ""
    
    # Use Nature Human Behaviour double column width
    # Respect original aspect ratio - do not deform
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 1.2))
    ax = fig.add_subplot(1, 1, 1)
    ax.axis('off')
    # Respect original aspect ratio - do not stretch or compress
    ax.imshow(img)
    
    out_path = str(OUT_DIR / 'figure_S3.png')
    plt.savefig(out_path, dpi=600, bbox_inches='tight', facecolor='white')
    plt.close()
    return out_path


def create_figure_S4() -> str:
    """Create Figure S4: DMT composite arousal index extended.
    
    Generates the plot directly using matplotlib, allowing for interactive editing.
    This figure should match the aesthetic of panel A from figure_2.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    print("  Generating Figure S4 (DMT Composite extended)...")
    
    # Import composite analysis functions
    sys.path.insert(0, str(SCRIPT_DIR))
    try:
        from run_composite_arousal_index import (
            load_and_prepare, zscore_within_subject, compute_pca_and_index,
            _compute_fdr_results, WINDOW_SIZE_SEC,
            COLOR_DMT_HIGH, COLOR_DMT_LOW, tab20b_colors
        )
    except ImportError as e:
        print(f"    [ERROR] Could not import composite functions: {e}")
        return ""
    
    import warnings
    
    # Load and prepare data
    try:
        df = load_and_prepare(limit_to_9min=False)
        df = zscore_within_subject(df)
        df, variance_explained, loadings, sign_flip_info = compute_pca_and_index(df)
    except Exception as e:
        print(f"    [ERROR] Failed to load/process composite data: {e}")
        return ""
    
    # Extract DMT data only
    dmt_df = df[df['State'] == 'DMT'].copy()
    
    if len(dmt_df) == 0:
        print("    [ERROR] No DMT data found")
        return ""
    
    subjects = sorted(dmt_df['subject'].unique())
    max_window = int(dmt_df['window'].max())
    
    # Build matrices
    high_mat, low_mat = [], []
    for subject in subjects:
        subj_df = dmt_df[dmt_df['subject'] == subject].sort_values('window')
        high_vals = np.full(max_window, np.nan)
        low_vals = np.full(max_window, np.nan)
        
        high_data = subj_df[subj_df['Dose'] == 'High']
        low_data = subj_df[subj_df['Dose'] == 'Low']
        
        for _, row in high_data.iterrows():
            window_idx = int(row['window']) - 1
            if 0 <= window_idx < max_window:
                high_vals[window_idx] = row['ArousalIndex']
        
        for _, row in low_data.iterrows():
            window_idx = int(row['window']) - 1
            if 0 <= window_idx < max_window:
                low_vals[window_idx] = row['ArousalIndex']
        
        if not np.all(np.isnan(high_vals)) and not np.all(np.isnan(low_vals)):
            high_mat.append(high_vals)
            low_mat.append(low_vals)
    
    if not high_mat or not low_mat:
        print("    [ERROR] No valid DMT data for plot")
        return ""
    
    H = np.array(high_mat)
    L = np.array(low_mat)
    
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", RuntimeWarning)
        mean_h = np.nanmean(H, axis=0)
        mean_l = np.nanmean(L, axis=0)
        n_valid_h = np.sum(~np.isnan(H), axis=0)
        n_valid_l = np.sum(~np.isnan(L), axis=0)
        sem_h = np.nanstd(H, axis=0, ddof=1) / np.sqrt(n_valid_h)
        sem_l = np.nanstd(L, axis=0, ddof=1) / np.sqrt(n_valid_l)
    
    window_grid = np.arange(1, max_window + 1)
    time_grid = (window_grid - 0.5) * WINDOW_SIZE_SEC / 60.0
    
    # Compute FDR
    fdr_results = _compute_fdr_results(H, L, window_grid, alternative='greater')
    segments = fdr_results.get('segments', [])
    
    # Create figure with Nature-compliant dimensions
    fig, ax = plt.subplots(1, 1, figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.4))
    
    # Shade significant segments
    for w0, w1 in segments:
        t0 = (w0 - 1) * WINDOW_SIZE_SEC / 60.0
        t1 = w1 * WINDOW_SIZE_SEC / 60.0
        ax.axvspan(t0, t1, color='0.85', alpha=0.35, zorder=0)
    
    # Plot lines
    l1 = ax.plot(time_grid, mean_h, color=COLOR_DMT_HIGH, lw=1.5, 
                 marker='o', markersize=3, label='High dose (40mg)')[0]
    ax.fill_between(time_grid, mean_h - sem_h, mean_h + sem_h, 
                    color=COLOR_DMT_HIGH, alpha=0.25)
    
    l2 = ax.plot(time_grid, mean_l, color=COLOR_DMT_LOW, lw=1.5, 
                 marker='o', markersize=3, label='Low dose (20mg)')[0]
    ax.fill_between(time_grid, mean_l - sem_l, mean_l + sem_l, 
                    color=COLOR_DMT_LOW, alpha=0.25)
    
    # Legend
    leg = ax.legend([l1, l2], ['High dose (40mg)', 'Low dose (20mg)'], 
                   loc=(0.698, 0.7257), frameon=True, fancybox=False, 
                   fontsize=FONT_SIZE_LEGEND, borderpad=0.4)
    leg.get_frame().set_facecolor('white')
    leg.get_frame().set_alpha(0.9)
    
    # Labels
    ax.set_xlabel('Time (minutes)', fontsize=FONT_SIZE_AXIS_LABEL)
    ax.text(-0.0967, 0.5, 'Composite Arousal', transform=ax.transAxes, 
            fontsize=FONT_SIZE_AXIS_LABEL, fontweight='bold', color=tab20b_colors[8],
            rotation=90, va='center', ha='center')
    ax.text(-0.06, 0.5, 'Index (PC1)', transform=ax.transAxes, 
            fontsize=FONT_SIZE_AXIS_LABEL, fontweight='normal', color='black', 
            rotation=90, va='center', ha='center')
    ax.set_title('DMT', fontweight='bold', fontsize=FONT_SIZE_TITLE)
    ax.tick_params(axis='both', labelsize=FONT_SIZE_TICK_LABEL)
    ax.grid(True, which='major', axis='y', alpha=0.25)
    ax.grid(False, which='major', axis='x')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    
    # X-axis
    max_time_min = max_window * WINDOW_SIZE_SEC / 60.0
    max_tick = int(np.ceil(max_time_min))
    ax.set_xticks(list(range(0, max_tick + 1)))
    ax.set_xlim(-0.2, max_time_min + 0.2)
    
    plt.tight_layout()
    out_path = str(OUT_DIR / 'figure_S4.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
    plt.close()
    
    print(f"    ✓ Figure S4 saved to: {out_path}")
    return out_path


def create_figure_S5() -> str:
    """Create Figure S5: Physiological Arousal Index vs TET Affective Dimensions."""
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    COUPLING_ROOT = PROJECT_ROOT / 'results' / 'coupling'
    
    try:
        merged_df = pd.read_csv(COUPLING_ROOT / 'merged_physio_tet_data.csv')
        regression_df = pd.read_csv(COUPLING_ROOT / 'regression_tet_arousal_index.csv')
    except FileNotFoundError:
        img = _load_image(str(COUPLING_ROOT / 'figures' / 'pc1_composite_4panel.png'))
        if img is None:
            return ""
        # Use Nature Human Behaviour double column width with consistent aspect ratio
        fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.7))
        ax = fig.add_subplot(1, 1, 1)
        ax.axis('off')
        ax.imshow(img, aspect='auto')
        out_path = str(OUT_DIR / 'figure_S5.png')
        plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
        plt.close()
        return out_path
    
    if 'ArousalIndex' not in merged_df.columns and 'physio_PC1' in merged_df.columns:
        merged_df['ArousalIndex'] = merged_df['physio_PC1']
    
    COLOR_RS, COLOR_DMT, COLOR_LINE = '#9E9AC8', '#5E4FA2', '#D62728'
    
    # Use Nature Human Behaviour double column width with consistent aspect ratio
    # 2x2 grid for 4 panels
    fig, axes = plt.subplots(2, 2, figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.7))
    outcomes = [('emotional_intensity_z', 'Emotional Intensity (Z)'),
                ('valence_index_z', 'Valence Index (Z)')]
    states = [('RS', COLOR_RS), ('DMT', COLOR_DMT)]
    state_titles = {'RS': 'Resting State (RS)', 'DMT': 'DMT'}
    
    for row, (outcome, ylabel) in enumerate(outcomes):
        for col, (state, color) in enumerate(states):
            ax = axes[row, col]
            state_data = merged_df[merged_df['state'] == state]
            
            reg = regression_df[(regression_df['outcome_variable'] == outcome) & 
                               (regression_df['state'] == state)]
            beta = reg['beta'].values[0] if len(reg) > 0 else np.nan
            r2 = reg['r_squared'].values[0] if len(reg) > 0 else np.nan
            pval = reg['p_value'].values[0] if len(reg) > 0 else np.nan
            
            x_col = 'ArousalIndex' if 'ArousalIndex' in state_data.columns else 'physio_PC1'
            if x_col in state_data.columns and outcome in state_data.columns:
                valid = state_data[[x_col, outcome]].dropna()
                ax.scatter(valid[x_col], valid[outcome], alpha=0.5, color=color, s=30, 
                          edgecolors='white', linewidths=0.5)
                
                if not np.isnan(beta) and len(valid) > 2:
                    x_line = np.linspace(valid[x_col].min(), valid[x_col].max(), 100)
                    slope, intercept = np.polyfit(valid[x_col], valid[outcome], 1)
                    ax.plot(x_line, slope * x_line + intercept, color=COLOR_LINE, 
                           linewidth=1.5, alpha=0.8)
            
            if not np.isnan(beta):
                sig = '***' if pval < 0.001 else '**' if pval < 0.01 else '*' if pval < 0.05 else ''
                ax.text(0.05, 0.95, f'β={beta:.2f}{sig}\nR²={r2:.3f}', 
                       transform=ax.transAxes, va='top', fontsize=FONT_SIZE_LEGEND,
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9, 
                                edgecolor='gray', linewidth=0.5))
            
            ax.set_title(state_titles[state], fontweight='bold', fontsize=FONT_SIZE_TITLE)
            ax.set_xlabel('Arousal Index (Physio PC1)', fontsize=FONT_SIZE_AXIS_LABEL)
            ax.set_ylabel(ylabel if col == 0 else '', fontsize=FONT_SIZE_AXIS_LABEL)
            ax.tick_params(labelsize=FONT_SIZE_TICK_LABEL)
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)
            ax.text(-0.15, 1.08, ['A', 'B', 'C', 'D'][row * 2 + col], 
                   transform=ax.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    
    plt.tight_layout()
    out_path = str(OUT_DIR / 'figure_S5.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
    plt.close()
    return out_path


# Registry of all figure creation functions
FIGURE_CREATORS: Dict[str, callable] = {
    '2': create_figure_2,
    '3': create_figure_3,
    '4': create_figure_4,
    '5': create_figure_5,
    'S1': create_figure_S1,
    'S2': create_figure_S2,
    'S3': create_figure_S3,
    'S4': create_figure_S4,
    'S5': create_figure_S5,
}


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Generate publication-ready figures for DMT-Emotions paper.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python src/run_figures.py                    # Generate all figures
  python src/run_figures.py --figures 2 3      # Generate only figures 2 and 3
  python src/run_figures.py --figures 4        # Generate only figure 4
  python src/run_figures.py --figures S1 S2    # Generate supplementary figures S1 and S2
  python src/run_figures.py --figures 2 S5     # Mix of main and supplementary
        """
    )
    parser.add_argument(
        '--figures', '-f',
        nargs='+',
        choices=list(FIGURE_CREATORS.keys()),
        help='Specific figures to generate (e.g., 2 3 4 S1). If not specified, generates all.'
    )
    return parser.parse_args()


def main() -> None:
    """Generate figures based on command line arguments."""
    args = parse_args()
    
    # Determine which figures to generate
    if args.figures:
        figures_to_generate = args.figures
    else:
        figures_to_generate = list(FIGURE_CREATORS.keys())
    
    print("=" * 60)
    print("FIGURE GENERATION")
    print("=" * 60)
    print(f"Figures to generate: {', '.join(figures_to_generate)}")
    print("Note: Figure 1 is a methods figure created separately.\n")
    
    results = {}
    for fig_id in figures_to_generate:
        print(f"\n--- Generating Figure {fig_id} ---")
        creator = FIGURE_CREATORS[fig_id]
        try:
            path = creator()
            if path:
                results[fig_id] = path
                print(f"  ✓ Figure {fig_id} saved to: {path}")
            else:
                print(f"  ✗ Figure {fig_id} failed (no output)")
        except Exception as e:
            print(f"  ✗ Figure {fig_id} failed: {e}")
    
    print("\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print(f"Generated {len(results)}/{len(figures_to_generate)} figures successfully.")
    for fig_id, path in results.items():
        print(f"  Figure {fig_id}: {Path(path).name}")


if __name__ == '__main__':
    main()

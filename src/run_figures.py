# -*- coding: utf-8 -*-
"""
Generate publication-ready composite panels for physiological figures (Nature Human Behaviour).

This script generates figures by running the individual analysis scripts as subprocesses
to create fresh plots, then assembles them into final composite figures.

NOTE: Figure 1 is a methods figure created separately. This script generates Figures 2-5.

Figure 2 (3x2 grid - Combined HR, SMNA, RVT):
  A-F: Generated by running run_ecg_hr_analysis.py, run_eda_smna_analysis.py, run_resp_rvt_analysis.py

Figure 3 (Composite Autonomic Arousal Index - 4 panels):
  A-D: Generated by running run_composite_arousal_index.py

Figure 4 (TET Analysis - 5 panels):
  A-E: Generated by running run_tet_analysis.py

Figure 5 (CCA Analysis - 4 panels):
  A-D: Generated from results/coupling/ data

Supplementary Figures:
  S1-S5: Various supplementary visualizations

Usage:
  python src/run_figures.py                    # Generate all figures
  python src/run_figures.py --figures 2 3      # Generate only figures 2 and 3
  python src/run_figures.py --figures 4        # Generate only figure 4
  python src/run_figures.py --figures S1 S2    # Generate only supplementary figures
  python src/run_figures.py --figures 2 S5     # Mix of main and supplementary
"""

import argparse
import os
import sys
from pathlib import Path
from typing import List, Tuple, Optional, Dict

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import pandas as pd

# Import centralized figure configuration
sys.path.insert(0, str(Path(__file__).parent))
try:
    from figure_config import (
        FONT_SIZE_PANEL_LABEL, FONT_SIZE_TITLE, FONT_SIZE_AXIS_LABEL,
        FONT_SIZE_TICK_LABEL, FONT_SIZE_LEGEND, FONT_SIZE_LEGEND_SMALL,
        DOUBLE_COL_WIDTH, FIG_SIZE_DOUBLE, FIG_SIZE_DOUBLE_TALL, apply_rcparams
    )
    apply_rcparams()
    PANEL_LABEL_SIZE = FONT_SIZE_PANEL_LABEL
except ImportError:
    # Fallback to Nature-compliant defaults
    PANEL_LABEL_SIZE = 12
    FONT_SIZE_TITLE = 10
    FONT_SIZE_AXIS_LABEL = 9
    FONT_SIZE_TICK_LABEL = 8
    FONT_SIZE_LEGEND = 8
    FONT_SIZE_LEGEND_SMALL = 7
    DOUBLE_COL_WIDTH = 7.2


# Project paths
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent
EDA_ROOT = PROJECT_ROOT / 'results' / 'eda'
ECG_ROOT = PROJECT_ROOT / 'results' / 'ecg'
RESP_ROOT = PROJECT_ROOT / 'results' / 'resp'
TET_ROOT = PROJECT_ROOT / 'results' / 'tet'
OUT_DIR = PROJECT_ROOT / 'results' / 'figures'


def _load_image(path: str):
    """Load image from path, return None if not found."""
    if not os.path.exists(path):
        print(f"[WARN] Missing image: {path}")
        return None
    try:
        return mpimg.imread(path)
    except Exception as e:
        print(f"[WARN] Failed to load {path}: {e}")
        return None


def _place(ax, img, label: str, label_xy: Tuple[float, float] = (-0.03, 1.08)):
    """Place image and label in subplot."""
    ax.axis('off')
    if img is not None:
        ax.imshow(img)
    ax.text(label_xy[0], label_xy[1], label, transform=ax.transAxes,
            ha='left', va='top', fontsize=PANEL_LABEL_SIZE, fontweight='bold', color='black')


def create_figure_2() -> str:
    """Create Figure 2: Combined HR, SMNA, and RVT analysis (3x2 grid).
    
    Generates the figure by running the analysis scripts as subprocesses to
    generate fresh plots, then assembling them into the final figure.
    
    Note: This requires that the raw data files exist for each modality.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    import subprocess
    
    # Run each analysis script to generate fresh plots
    print("  Generating ECG/HR plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_ecg_hr_analysis.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ ECG analysis completed")
        else:
            print(f"    [WARN] ECG analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] ECG analysis timed out")
    except Exception as e:
        print(f"    [WARN] ECG analysis failed: {e}")
    
    print("  Generating EDA/SMNA plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_eda_smna_analysis.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ EDA analysis completed")
        else:
            print(f"    [WARN] EDA analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] EDA analysis timed out")
    except Exception as e:
        print(f"    [WARN] EDA analysis failed: {e}")
    
    print("  Generating Resp/RVT plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_resp_rvt_analysis.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ Resp analysis completed")
        else:
            print(f"    [WARN] Resp analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] Resp analysis timed out")
    except Exception as e:
        print(f"    [WARN] Resp analysis failed: {e}")
    
    # Now load the generated images and assemble the figure
    print("  Assembling Figure 2...")
    imgs = [
        _load_image(str(ECG_ROOT / 'hr' / 'plots' / 'all_subs_ecg_hr.png')),
        _load_image(str(ECG_ROOT / 'hr' / 'plots' / 'lme_coefficient_plot.png')),
        _load_image(str(EDA_ROOT / 'smna' / 'plots' / 'all_subs_smna.png')),
        _load_image(str(EDA_ROOT / 'smna' / 'plots' / 'lme_coefficient_plot.png')),
        _load_image(str(RESP_ROOT / 'rvt' / 'plots' / 'all_subs_resp_rvt.png')),
        _load_image(str(RESP_ROOT / 'rvt' / 'plots' / 'lme_coefficient_plot.png')),
    ]

    # Use Nature Human Behaviour double column width (183mm = 7.2 inches)
    # Create figure with 3 rows x 2 columns
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 1.0))
    
    # Calculate aspect ratios from actual images to maintain proportions
    # Left images (timeseries) are wider, right images (coefficient) are narrower
    # Use width_ratios based on actual image dimensions
    if imgs[0] is not None and imgs[1] is not None:
        left_aspect = imgs[0].shape[1] / imgs[0].shape[0]  # width/height
        right_aspect = imgs[1].shape[1] / imgs[1].shape[0]
        width_ratio = left_aspect / right_aspect
    else:
        width_ratio = 2.0
    
    gs = fig.add_gridspec(3, 2, width_ratios=[width_ratio, 1.0], 
                          wspace=0.05, hspace=0.08,
                          left=0.01, right=0.99, top=0.97, bottom=0.03)
    
    axes = [fig.add_subplot(gs[i, j]) for i in range(3) for j in range(2)]
    
    # Place images maintaining their aspect ratio
    for idx, (ax, img) in enumerate(zip(axes, imgs)):
        ax.axis('off')
        if img is not None:
            # Use aspect='equal' to maintain image proportions
            ax.imshow(img, aspect='equal')
            # Adjust axis limits to remove whitespace
            ax.set_xlim(0, img.shape[1])
            ax.set_ylim(img.shape[0], 0)
    
    # Add panel labels - calculate positions based on gridspec
    labels = ['A', 'B', 'C', 'D', 'E', 'F']
    row_tops = [0.97, 0.66, 0.35]  # Approximate top positions for each row
    
    for i, label in enumerate(labels):
        row = i // 2
        col = i % 2
        # Position labels at consistent heights per row
        if col == 0:
            x_pos = 0.01
        else:
            x_pos = width_ratio / (width_ratio + 1.0) + 0.01
        y_pos = row_tops[row]
        fig.text(x_pos, y_pos, label, 
                fontsize=PANEL_LABEL_SIZE, fontweight='bold', ha='left', va='top')
    
    out_path = str(OUT_DIR / 'figure_2.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_3() -> str:
    """Create Figure 3: Composite Autonomic Arousal Index (4 panels).
    
    Generates the figure by running the composite arousal index analysis script
    as a subprocess to generate fresh plots, then assembling them into the final figure.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    COMPOSITE_ROOT = PROJECT_ROOT / 'results' / 'composite' / 'plots'
    
    import subprocess
    
    print("  Generating Composite Arousal Index plots...")
    try:
        result = subprocess.run(
            ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_composite_arousal_index.py'],
            capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
        )
        if result.returncode == 0:
            print("    ✓ Composite analysis completed")
        else:
            print(f"    [WARN] Composite analysis failed: {result.stderr[:200] if result.stderr else 'Unknown error'}")
    except subprocess.TimeoutExpired:
        print("    [WARN] Composite analysis timed out")
    except Exception as e:
        print(f"    [WARN] Composite analysis failed: {e}")

    # Now load the generated images and assemble the figure
    print("  Assembling Figure 3...")
    imgs = [
        _load_image(str(COMPOSITE_ROOT / 'pca_scree.png')),
        _load_image(str(COMPOSITE_ROOT / 'pca_pc1_loadings.png')),
        _load_image(str(COMPOSITE_ROOT / 'lme_coefficient_plot.png')),
        _load_image(str(COMPOSITE_ROOT / 'all_subs_composite.png')),
    ]

    # Use Nature Human Behaviour double column width
    # 4 panels: A, B (left column), C (right top), D (bottom full width)
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 1.1))
    gs = fig.add_gridspec(4, 2, width_ratios=[0.5, 1.0], wspace=0.15, hspace=0.20,
                          left=0.05, right=0.98, top=0.97, bottom=0.03)
    
    ax_A = fig.add_subplot(gs[0, 0])
    ax_B = fig.add_subplot(gs[1, 0])
    ax_C = fig.add_subplot(gs[0:2, 1])
    ax_D = fig.add_subplot(gs[2:4, :])
    
    for ax, img in zip([ax_A, ax_B, ax_C, ax_D], imgs):
        ax.axis('off')
        if img is not None:
            ax.imshow(img)
    
    for ax, label, offset in zip([ax_A, ax_B, ax_C, ax_D], 
                                  ['A', 'C', 'B', 'D'], 
                                  [0.02, 0.02, 0.02, 0.02]):
        pos = ax.get_position()
        fig.text(pos.x0 - 0.02, pos.y1 + offset, label,
                fontsize=PANEL_LABEL_SIZE, fontweight='bold', ha='left', va='top')

    out_path = str(OUT_DIR / 'figure_3.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_4() -> str:
    """Create Figure 4: TET Analysis (5 panels).
    
    Generates the figure by calling the plotting functions from run_tet_analysis.py
    directly, ensuring identical layout to the original composite figure.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    # Import the TET analysis module and use its functions directly
    import sys
    sys.path.insert(0, str(SCRIPT_DIR))
    
    try:
        from run_tet_analysis import (
            load_data, compute_pca, fit_lme_models, compute_time_courses,
            compute_significance_masks, plot_figure3, DATA_PATH
        )
    except ImportError as e:
        print(f"[ERROR] Could not import run_tet_analysis: {e}")
        return ""
    
    # Check if data exists
    if not DATA_PATH.exists():
        print(f"[ERROR] TET data not found: {DATA_PATH}")
        print("  Run preprocessing first.")
        return ""
    
    print("  Loading TET data and computing analysis...")
    
    # Run the analysis pipeline
    df = load_data()
    df, loadings, variance_explained = compute_pca(df)
    lme_results, df_all = fit_lme_models(df)
    time_courses = compute_time_courses(df)
    significance = compute_significance_masks(df)
    
    # Generate the figure using the original function
    # This ensures identical layout
    fig_path = plot_figure3(df, time_courses, loadings, variance_explained, 
                            lme_results, significance)
    
    # Copy to the figures output directory
    import shutil
    out_path = str(OUT_DIR / 'figure_4.png')
    shutil.copy2(fig_path, out_path)
    
    return out_path


def create_figure_5() -> str:
    """Create Figure 5: Combined CCA Analysis (4 panels)."""
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    CCA_ROOT = PROJECT_ROOT / 'results' / 'coupling'
    
    try:
        loadings_df = pd.read_csv(CCA_ROOT / 'cca_loadings.csv')
        cv_folds_df = pd.read_csv(CCA_ROOT / 'cca_cross_validation_folds.csv')
        cv_summary_df = pd.read_csv(CCA_ROOT / 'cca_cross_validation_summary.csv')
        merged_data_df = pd.read_csv(CCA_ROOT / 'merged_physio_tet_data.csv')
    except FileNotFoundError as e:
        print(f"[ERROR] Missing CCA data file: {e}")
        return ""
    
    plt.rcParams.update({
        'font.family': 'sans-serif', 'font.size': 7, 'axes.labelsize': 7,
        'axes.titlesize': 8, 'xtick.labelsize': 6, 'ytick.labelsize': 7,
        'legend.fontsize': 6, 'axes.linewidth': 0.5,
    })
    
    tab20c = plt.cm.tab20c.colors
    physio_colors = {'HR': tab20c[0], 'SMNA_AUC': tab20c[4], 'RVT': tab20c[8]}
    gray_colors = [tab20c[12], tab20c[13], tab20c[14], tab20c[15]]
    color_rs, color_rs_edge = tab20c[17], tab20c[16]
    color_dmt, color_dmt_edge = tab20c[13], tab20c[12]
    
    fig_width = 183 / 25.4
    fig = plt.figure(figsize=(fig_width, fig_width * 0.78))
    gs = fig.add_gridspec(2, 2, width_ratios=[1, 1.5], wspace=0.35, hspace=0.4)
    
    ax_A, ax_B = fig.add_subplot(gs[0, 0]), fig.add_subplot(gs[0, 1])
    ax_C, ax_D = fig.add_subplot(gs[1, 0]), fig.add_subplot(gs[1, 1])
    
    state, cv = 'DMT', 1
    data = loadings_df[(loadings_df['state'] == state) & (loadings_df['canonical_variate'] == cv)]
    physio_data = data[data['variable_set'] == 'physio'].sort_values('loading', ascending=True)
    tet_data = data[data['variable_set'] == 'tet'].sort_values('loading', ascending=True)
    
    physio_labels = {'HR': ('ECG', 'HR'), 'SMNA_AUC': ('EDA', 'SMNA'), 'RVT': ('Resp', 'RVT')}
    tet_labels = {'emotional_intensity': 'Emotional Intensity', 'interoception': 'Interoception',
                  'unpleasantness': 'Unpleasantness', 'pleasantness': 'Pleasantness',
                  'bliss': 'Bliss', 'anxiety': 'Anxiety'}
    
    # Panel A: Physio loadings
    for i, (_, row) in enumerate(physio_data.iterrows()):
        ax_A.barh(i, row['loading'], height=0.6, 
                 color=physio_colors.get(row['variable_name'], '#666'), alpha=0.85)
    ax_A.set_yticks(range(len(physio_data)))
    ax_A.set_yticklabels([physio_labels.get(v, (v, v))[0] for v in physio_data['variable_name']])
    ax_A.set_xlabel('Canonical Loading')
    ax_A.set_title('Physiological Variables', fontweight='bold')
    ax_A.axvline(0, color='black', linewidth=0.5, alpha=0.3)
    ax_A.spines['top'].set_visible(False)
    ax_A.spines['right'].set_visible(False)
    
    # Panel B: TET loadings
    for i, (_, row) in enumerate(tet_data.iterrows()):
        ax_B.barh(i, row['loading'], height=0.6, color=gray_colors[i % 4], alpha=0.85)
    ax_B.set_yticks(range(len(tet_data)))
    ax_B.set_yticklabels([tet_labels.get(v, v) for v in tet_data['variable_name']])
    ax_B.set_xlabel('Canonical Loading')
    ax_B.set_title('Affective Dimensions', fontweight='bold')
    ax_B.axvline(0, color='black', linewidth=0.5, alpha=0.3)
    ax_B.spines['top'].set_visible(False)
    ax_B.spines['right'].set_visible(False)
    
    # Panel C: CV boxplots
    cv_cv1 = cv_folds_df[cv_folds_df['canonical_variate'] == 1]
    rs_cv = cv_cv1[cv_cv1['state'] == 'RS']['r_oos'].values
    dmt_cv = cv_cv1[cv_cv1['state'] == 'DMT']['r_oos'].values
    
    bp = ax_C.boxplot([rs_cv, dmt_cv], positions=[0.8, 1.6], widths=0.3, patch_artist=True)
    bp['boxes'][0].set_facecolor(color_rs)
    bp['boxes'][1].set_facecolor(color_dmt)
    ax_C.set_xticks([0.8, 1.6])
    ax_C.set_xticklabels(['RS', 'DMT'])
    ax_C.set_ylabel('Out-of-sample r')
    ax_C.set_title('Cross-validation (CV1)', fontweight='bold')
    ax_C.axhline(0, color='black', linestyle='--', linewidth=0.5, alpha=0.5)
    ax_C.spines['top'].set_visible(False)
    ax_C.spines['right'].set_visible(False)
    
    # Panel D: Scatterplot
    from sklearn.cross_decomposition import CCA
    dmt_merged = merged_data_df[merged_data_df['state'] == 'DMT'].copy()
    X = dmt_merged[['HR', 'SMNA_AUC', 'RVT']].values
    Y = dmt_merged[['pleasantness_z', 'unpleasantness_z', 'emotional_intensity_z',
                    'interoception_z', 'bliss_z', 'anxiety_z']].values
    subjects = dmt_merged['subject'].values
    
    valid = ~(np.isnan(X).any(axis=1) | np.isnan(Y).any(axis=1))
    X, Y, subjects = X[valid], Y[valid], subjects[valid]
    X = (X - X.mean(0)) / X.std(0)
    Y = (Y - Y.mean(0)) / Y.std(0)
    
    cca = CCA(n_components=2)
    cca.fit(X, Y)
    U, V = cca.transform(X, Y)
    
    tab20 = plt.cm.tab20.colors
    for i, subj in enumerate(np.unique(subjects)):
        mask = subjects == subj
        ax_D.scatter(U[mask, 0], V[mask, 0], s=30, color=tab20[(i % 10) * 2 + 1],
                    alpha=0.7, edgecolors=tab20[(i % 10) * 2], linewidths=0.5, label=subj)
    
    z = np.polyfit(U[:, 0], V[:, 0], 1)
    x_line = np.linspace(U[:, 0].min(), U[:, 0].max(), 100)
    ax_D.plot(x_line, np.poly1d(z)(x_line), 'r--', linewidth=1.5, alpha=0.8)
    
    in_r = cv_summary_df[(cv_summary_df['state'] == 'DMT') & 
                         (cv_summary_df['canonical_variate'] == 1)]['in_sample_r'].values[0]
    ax_D.text(0.98, 0.95, f'r = {in_r:.2f}', transform=ax_D.transAxes,
             ha='right', va='top', fontsize=FONT_SIZE_LEGEND_SMALL, style='italic', fontweight='bold')
    ax_D.set_xlabel('Physiological Score (U1)')
    ax_D.set_ylabel('TET Score (V1)')
    ax_D.set_title('In-sample coupling (DMT)', fontweight='bold')
    ax_D.spines['top'].set_visible(False)
    ax_D.spines['right'].set_visible(False)
    ax_D.legend(loc='lower right', fontsize=FONT_SIZE_LEGEND_SMALL, ncol=2)
    
    for ax, label, x_off in [(ax_A, 'A', -0.35), (ax_B, 'B', -0.15), 
                              (ax_C, 'C', -0.35), (ax_D, 'D', -0.15)]:
        ax.text(x_off, 1.15, label, transform=ax.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    
    plt.tight_layout()
    out_path = str(OUT_DIR / 'figure_5.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
    plt.close()
    return out_path


def create_figure_S1() -> str:
    """Create Figure S1: Stacked subjects for all modalities (1x3 horizontal).
    
    Uses the stacked subject plots generated by the individual analysis scripts.
    Runs the scripts as subprocesses if plots don't exist.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    import subprocess
    
    # Check if plots exist, if not run the analysis scripts
    ecg_stacked = ECG_ROOT / 'hr' / 'plots' / 'stacked_subs_ecg_hr.png'
    eda_stacked = EDA_ROOT / 'smna' / 'plots' / 'stacked_subs_smna.png'
    resp_stacked = RESP_ROOT / 'rvt' / 'plots' / 'stacked_subs_resp_rvt.png'
    
    if not ecg_stacked.exists():
        print("  Generating ECG stacked plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_ecg_hr_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] ECG analysis failed: {e}")
    
    if not eda_stacked.exists():
        print("  Generating EDA stacked plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_eda_smna_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] EDA analysis failed: {e}")
    
    if not resp_stacked.exists():
        print("  Generating Resp stacked plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_resp_rvt_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] Resp analysis failed: {e}")

    # Load generated images
    print("  Assembling Figure S1...")
    imgs = [
        _load_image(str(ecg_stacked)),
        _load_image(str(eda_stacked)),
        _load_image(str(resp_stacked)),
    ]

    # Use Nature Human Behaviour double column width
    # 3 panels horizontally: A, B, C
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.35))
    
    for i, (img, label) in enumerate(zip(imgs, ['A', 'B', 'C'])):
        if img is not None:
            aspect = img.shape[0] / img.shape[1]
            width = 0.33
            height = width * aspect
            ax = fig.add_axes([0.01 + i * 0.325, 0.99 - height, width, height])
            ax.axis('off')
            ax.imshow(img)
            pos = ax.get_position()
            fig.text(pos.x0 - 0.005, pos.y1 + 0.02, label, 
                    fontsize=PANEL_LABEL_SIZE, fontweight='bold', ha='left', va='top')

    out_path = str(OUT_DIR / 'figure_S1.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_S2() -> str:
    """Create Figure S2: DMT ECG HR extended timecourse.
    
    Uses the extended DMT plot generated by the ECG analysis script.
    Runs the script as subprocess if plot doesn't exist.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    import subprocess
    
    ecg_dmt_plot = ECG_ROOT / 'hr' / 'plots' / 'all_subs_dmt_ecg_hr.png'
    
    if not ecg_dmt_plot.exists():
        print("  Generating extended DMT ECG/HR plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_ecg_hr_analysis.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] ECG analysis failed: {e}")
    
    print("  Assembling Figure S2...")
    img = _load_image(str(ecg_dmt_plot))
    if img is None:
        return ""
    
    # Use Nature Human Behaviour double column width
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.5))
    ax = fig.add_subplot(1, 1, 1)
    ax.axis('off')
    ax.imshow(img)
    
    out_path = str(OUT_DIR / 'figure_S2.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_S3() -> str:
    """Create Figure S3: Stacked subjects composite arousal index.
    
    Uses the stacked subjects plot generated by the composite analysis script.
    Runs the script as subprocess if plot doesn't exist.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    import subprocess
    
    composite_stacked = PROJECT_ROOT / 'results' / 'composite' / 'plots' / 'stacked_subs_composite.png'
    
    if not composite_stacked.exists():
        print("  Generating stacked subjects composite plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_composite_arousal_index.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] Composite analysis failed: {e}")
    
    print("  Assembling Figure S3...")
    img = _load_image(str(composite_stacked))
    if img is None:
        return ""
    
    # Use Nature Human Behaviour double column width
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 1.5))
    ax = fig.add_subplot(1, 1, 1)
    ax.axis('off')
    ax.imshow(img)
    
    out_path = str(OUT_DIR / 'figure_S3.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_S4() -> str:
    """Create Figure S4: DMT composite arousal index extended.
    
    Uses the extended DMT plot generated by the composite analysis script.
    Runs the script as subprocess if plot doesn't exist.
    """
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    import subprocess
    
    composite_dmt = PROJECT_ROOT / 'results' / 'composite' / 'plots' / 'all_subs_dmt_composite.png'
    
    if not composite_dmt.exists():
        print("  Generating extended DMT composite plot...")
        try:
            subprocess.run(
                ['micromamba', 'run', '-n', 'dmt-emotions', 'python', 'src/run_composite_arousal_index.py'],
                capture_output=True, text=True, timeout=300, cwd=str(PROJECT_ROOT)
            )
        except Exception as e:
            print(f"    [WARN] Composite analysis failed: {e}")
    
    print("  Assembling Figure S4...")
    img = _load_image(str(composite_dmt))
    if img is None:
        return ""
    
    # Use Nature Human Behaviour double column width
    fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.5))
    ax = fig.add_subplot(1, 1, 1)
    ax.axis('off')
    ax.imshow(img)
    
    out_path = str(OUT_DIR / 'figure_S4.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    plt.close()
    return out_path


def create_figure_S5() -> str:
    """Create Figure S5: Physiological Arousal Index vs TET Affective Dimensions."""
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    COUPLING_ROOT = PROJECT_ROOT / 'results' / 'coupling'
    
    try:
        merged_df = pd.read_csv(COUPLING_ROOT / 'merged_physio_tet_data.csv')
        regression_df = pd.read_csv(COUPLING_ROOT / 'regression_tet_arousal_index.csv')
    except FileNotFoundError:
        img = _load_image(str(COUPLING_ROOT / 'figures' / 'pc1_composite_4panel.png'))
        if img is None:
            return ""
        # Use Nature Human Behaviour double column width
        fig = plt.figure(figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.8))
        ax = fig.add_subplot(1, 1, 1)
        ax.axis('off')
        ax.imshow(img)
        out_path = str(OUT_DIR / 'figure_S5.png')
        plt.savefig(out_path, dpi=300, bbox_inches='tight')
        plt.close()
        return out_path
    
    if 'ArousalIndex' not in merged_df.columns and 'physio_PC1' in merged_df.columns:
        merged_df['ArousalIndex'] = merged_df['physio_PC1']
    
    COLOR_RS, COLOR_DMT, COLOR_LINE = '#9E9AC8', '#5E4FA2', '#D62728'
    
    # Use Nature Human Behaviour double column width
    # 2x2 grid for 4 panels
    fig, axes = plt.subplots(2, 2, figsize=(DOUBLE_COL_WIDTH, DOUBLE_COL_WIDTH * 0.8))
    outcomes = [('emotional_intensity_z', 'Emotional Intensity (Z)'),
                ('valence_index_z', 'Valence Index (Z)')]
    states = [('RS', COLOR_RS), ('DMT', COLOR_DMT)]
    
    for row, (outcome, ylabel) in enumerate(outcomes):
        for col, (state, color) in enumerate(states):
            ax = axes[row, col]
            state_data = merged_df[merged_df['state'] == state]
            
            reg = regression_df[(regression_df['outcome_variable'] == outcome) & 
                               (regression_df['state'] == state)]
            beta = reg['beta'].values[0] if len(reg) > 0 else np.nan
            r2 = reg['r_squared'].values[0] if len(reg) > 0 else np.nan
            pval = reg['p_value'].values[0] if len(reg) > 0 else np.nan
            
            x_col = 'ArousalIndex' if 'ArousalIndex' in state_data.columns else 'physio_PC1'
            if x_col in state_data.columns and outcome in state_data.columns:
                valid = state_data[[x_col, outcome]].dropna()
                ax.scatter(valid[x_col], valid[outcome], alpha=0.4, color=color, s=25)
                
                if not np.isnan(beta) and len(valid) > 2:
                    x_line = np.linspace(valid[x_col].min(), valid[x_col].max(), 100)
                    slope, intercept = np.polyfit(valid[x_col], valid[outcome], 1)
                    ax.plot(x_line, slope * x_line + intercept, color=COLOR_LINE, linewidth=2)
            
            if not np.isnan(beta):
                sig = '***' if pval < 0.001 else '**' if pval < 0.01 else '*' if pval < 0.05 else ''
                ax.text(0.05, 0.95, f'β={beta:.2f}{sig}\nR²={r2:.3f}', 
                       transform=ax.transAxes, va='top', fontsize=FONT_SIZE_AXIS_LABEL,
                       bbox=dict(boxstyle='round', facecolor='white', alpha=0.9))
            
            ax.set_title(state, fontweight='bold', fontsize=FONT_SIZE_TITLE)
            ax.set_xlabel('Arousal Index (Physio PC1)', fontsize=FONT_SIZE_TICK_LABEL, fontweight='bold')
            ax.set_ylabel(ylabel if col == 0 else '', fontsize=FONT_SIZE_TICK_LABEL, fontweight='bold')
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)
            ax.text(-0.12, 1.08, ['A', 'B', 'C', 'D'][row * 2 + col], 
                   transform=ax.transAxes, fontsize=PANEL_LABEL_SIZE, fontweight='bold')
    
    plt.tight_layout()
    out_path = str(OUT_DIR / 'figure_S5.png')
    plt.savefig(out_path, dpi=300, bbox_inches='tight', facecolor='white')
    plt.close()
    return out_path


# Registry of all figure creation functions
FIGURE_CREATORS: Dict[str, callable] = {
    '2': create_figure_2,
    '3': create_figure_3,
    '4': create_figure_4,
    '5': create_figure_5,
    'S1': create_figure_S1,
    'S2': create_figure_S2,
    'S3': create_figure_S3,
    'S4': create_figure_S4,
    'S5': create_figure_S5,
}


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Generate publication-ready figures for DMT-Emotions paper.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python src/run_figures.py                    # Generate all figures
  python src/run_figures.py --figures 2 3      # Generate only figures 2 and 3
  python src/run_figures.py --figures 4        # Generate only figure 4
  python src/run_figures.py --figures S1 S2    # Generate supplementary figures S1 and S2
  python src/run_figures.py --figures 2 S5     # Mix of main and supplementary
        """
    )
    parser.add_argument(
        '--figures', '-f',
        nargs='+',
        choices=list(FIGURE_CREATORS.keys()),
        help='Specific figures to generate (e.g., 2 3 4 S1). If not specified, generates all.'
    )
    return parser.parse_args()


def main() -> None:
    """Generate figures based on command line arguments."""
    args = parse_args()
    
    # Determine which figures to generate
    if args.figures:
        figures_to_generate = args.figures
    else:
        figures_to_generate = list(FIGURE_CREATORS.keys())
    
    print("=" * 60)
    print("FIGURE GENERATION")
    print("=" * 60)
    print(f"Figures to generate: {', '.join(figures_to_generate)}")
    print("Note: Figure 1 is a methods figure created separately.\n")
    
    results = {}
    for fig_id in figures_to_generate:
        print(f"\n--- Generating Figure {fig_id} ---")
        creator = FIGURE_CREATORS[fig_id]
        try:
            path = creator()
            if path:
                results[fig_id] = path
                print(f"  ✓ Figure {fig_id} saved to: {path}")
            else:
                print(f"  ✗ Figure {fig_id} failed (no output)")
        except Exception as e:
            print(f"  ✗ Figure {fig_id} failed: {e}")
    
    print("\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print(f"Generated {len(results)}/{len(figures_to_generate)} figures successfully.")
    for fig_id, path in results.items():
        print(f"  Figure {fig_id}: {Path(path).name}")


if __name__ == '__main__':
    main()
